@startuml
object Api {
    auth.registers(request: UserRequest): UserResponse
    auth.login(request: UserRequest): UserResponse
    auth.refresh_token(request: Request): Response
    auth.logout(request: Request): Response

    users.get_users(request: Request): list[UserResponse]
    users.get_user(request: Request): UserResponse
}
entity UserRequest
entity UserResponse
class UserManager{
    create_user(data: dict): User
    authenticate(credentials: dict): User
    save_login_history(data: dict, request_data: dict): LoginHistory

    _hashed_password(password: str): str
}
class JWT{
    assess_token
    refresh_token

    write_token(user: User): str
    read_token(token: str, user_manager: UserManager): User | None
    destroy_token(token: str, user: User): None

    _generate_jwt(data: dict): str
    _decode_jwt(encoded_jwt: str): dict
}
entity User
entity LoginHistory

Api *-- UserRequest
Api *-- UserResponse
Api o.. UserManager
Api o.right. JWT

UserManager *-down- User
UserManager *-down- LoginHistory

@enduml

@startuml
'https://plantuml.com/sequence-diagram

hide footbox
skinparam stereotypePosition bottom
skinparam ParticipantPadding 20
skinparam BoxPadding 10
'skinparam sequenceMessageAlign reverseDirection

header %date("dd MMMM YYYY")
title AuthApi service

actor Client

box "Api"
participant UserApi <<routes /users/*>>
participant AuthApi <<routes /auth/*>>
end box

box "Schemas"
entity UserRequest
entity UserResponse
end box

box "Services"
participant UserManager
participant JWT.accessToken
participant JWT.refreshToken
end box

box "Models"
entity User
entity LoginHistory
end box

box
database Postgres
database Redis
end box
== Registers ==

Client -> AuthApi: **POST /auth/registers** \n-d {username, email, password, confirm_password}
AuthApi -> UserRequest: validate_data = validate(request data)
AuthApi -> UserManager: user = **create_user**(validate_data)
UserManager -> UserManager: hashed_password = **_hash_password(password)**
UserManager --> User: **create** User(username, email, hashed_password)
User --> Postgres: save User
AuthApi -> UserResponse: response_data(user)
AuthApi -> Client: **201 Created** -d {id, username, email}

== Login ==

Client -> AuthApi: **POST /auth/login** \n-d {login, password}
AuthApi -> UserManager: user = **authenticate**(credentials={login, password})
AuthApi -> JWT.accessToken: access_token = **write_token(user)**
note over JWT.accessToken
{
    "header": {"alg":"HS256", "typ":"JWT"},
    "payload": {
        "user": "UUID",
        "iat": now(),
        "exp": now() + 10 sec,
        "role": "guest" ???
    }
}
end note
activate JWT.accessToken #green

AuthApi -> JWT.refreshToken: refresh_token = **write_token(user)**
note over JWT.refreshToken
{
    "header": {"alg":"HS256", "typ":"JWT"},
    "payload": {
        "user": "UUID",
        "iat": now(),
        "exp": now() + 1 year,
    }
}
end note
activate JWT.refreshToken #green
JWT.refreshToken --> Postgres: save refresh_token

AuthApi --> UserManager: **save_login_history(user, <request data>)**
UserManager --> LoginHistory: create LoginHistory(data)
LoginHistory --> Postgres: save login_history

AuthApi -> Client: 200 OK -d {access token, refresh token}

== Requests ==

Client -> UserApi: **GET /users/me** -h Authorization "bearer <access_token>"
UserApi -> JWT.accessToken: user = **read_token(access_token)**
UserApi -> UserResponse: response_data(user)
Client <- UserApi: 200 OK -d {response_data}

?--> JWT.accessToken: **Expire access token**
destroy JWT.accessToken #green

|||

Client -> UserApi: **GET /users/me** -h Authorization "bearer <access_token>"
UserApi -> JWT.accessToken: user = **read_token(access_token)**
Client <- UserApi: 401 UNAUTHORIZED -d {message}

== Refresh access token ==

Client -> AuthApi: **POST /auth/refresh_token** -h Authorization "bearer <refresh_token>"
AuthApi --> JWT.accessToken: access_token = **write_token(user)**
activate JWT.accessToken #green

AuthApi -> Client: 200 OK -d {access_token}

== Logout ==

Client -> AuthApi: **POST /auth/logout** -h Authorization "bearer <access_token>"
AuthApi --> JWT.accessToken: user = **read_token(access_token)**
AuthApi --> JWT.accessToken: **destroy_token(access_token, user)**
destroy JWT.accessToken

note right AuthApi
? Непонятно откуда мы берем refresh_token ?
end note
AuthApi --> JWT.refreshToken: **destroy_token(refresh_token, user)**
destroy JWT.refreshToken

JWT.refreshToken --> Postgres: delete refresh_token

AuthApi -> Client: 204 NO CONTENT
@enduml